---
title: Homework 13
layout: single
due:
---

# My HW3 Pete's HW2 RPN calc
 
 # My HW4, Pete's HW3: Propositional Logic basics
	Truth tables. 
	Satisfiability
	Falsifability
	Validity

Proof Trees aka "Semantic tableaux"
Quine McClusky Alg

"Show me a man with a tattoo, and I’ll show you a man with an interesting past." 
—Jack London


	```
  NOT     !

  AND     &
  OR      v

  IMPLIES =>

  EQUIV   ==
  XOR     ><
	```
 
 
# My HW5, Pete's HW4 Substitutions, Equational Reasoning, Quine McCusky alg? 
  Minimization of Boolean expressions, certainly.e
  
#   
  


> Mathematics is concerned only with the enumeration and comparison of relations.
> -- Carl Friedrich Gauss


# Substitutions, composition of substitutions, mapping substitutions one across another. 
# Complexities of substitutions.
# Idempotent substitutions.
# Triangular substitution representation. 

# Pete's HWK1 could be a source of interesting problems

https://www.khoury.northeastern.edu/~pete/courses/Logic-and-Computation/2020-Spring/hwk01.lisp

# HW3 will be on an RPN calculator w/variables.

# Lab 3 is on writing down and formalizing conjectures. Then making them executable. Can do.

https://www.khoury.northeastern.edu/~pete/courses/Logic-and-Computation/2020-Spring/lab03.lisp


# Easy to do

(defdata vbl symbol)

(defdata app (record (rator . symbol)
		     (rand . symbol)))

(defdata lamexp (record (var . symbol)
			(body . lamcalcexp)))

# Need to build mutually-recursive data definitions. How?
  Because I am not doing that (eq? (car ...)) noise.
  
  Now doable b/c see paper on acl2s defdata definitions. 

## These problems depend on it
;; lambda->lumbda
;; var-occurs?
;; vars
;; var-occurs-free?
;; var-occurs-bound?

## STLC Strongly-normalizing. 


# Show now that we have set:: operations. 

# Need/want some notion of sets ( unique elem lists )

;; +set-difference 
;; +union
;; cartesian-product
;; unique-vars
;; unique-free-vars
;; unique-bound-vars

# Hard to do in an interesting way
;; minus 
;; div (on a divisible abelian group)

# Hard to make into a problem
;; mccarthy reverse?

# Can't do b/c fo-language.

;; foldr
;; foldr-based-versions
;; map
;; append-map



      (test-suite "list-index-ofv?"
      (test-equal-if-defined list-index-ofv? 
       ((list-index-ofv? 'x '(x y z x x)) 0)
       ((list-index-ofv? 'x '(y z x x)) 2)))
	   
	   
	   
	   
	        (test-suite "zip"
     (test-equal-if-defined
      zip
      [(zip '(1 2 3) '(a b c)) '((1 . a) (2 . b) (3 . c))]
      [(zip '() '()) '()]
      [(zip '(x) '(y)) '((x . y))]
      [(zip '(a b) '((foo . bar) (baz . quux))) '((a foo . bar) (b baz . quux))]
      [(zip '(1 2 3 4 5 6) '(a b c))
       '((1 . a) (2 . b) (3 . c))]
      [(zip '(1 2 3) '(a b c d e f))
       '((1 . a) (2 . b) (3 . c))]))

     (test-suite "append"
     (test-equal-if-defined
      append
      [(append '(a b c) '(1 2 3)) '(a b c 1 2 3)]
      [(append '() '(foo bar baz)) '(foo bar baz)]
      [(append '(foo bar baz) '()) '(foo bar baz)]
      [(append '(once upon a) '(time)) '(once upon a time)]
      [(append '(once upon a) (append '(time) '(in a land far away))) '(once upon a time in a land far away)]))

     (test-suite "reverse"
     (test-equal-if-defined
      reverse
      [(reverse '(a 3 x)) '(x 3 a)]
      [(reverse '(a)) '(a)]
      [(reverse '(5 4 3 2 1)) '(1 2 3 4 5)]))

     (test-suite "fact"
     (test-equal-if-defined
      fact
      [(fact 5) 120]
      [(fact 0) 1]
      [(fact 1) 1]
      [(fact 10) 3628800]))

     (test-suite "memv"   
     (test-equal-if-defined memv
       [(memv 'a '(a b c)) '(a b c)]
       [(memv 'b '(a ? c)) #f]
       [(memv 'b '(a b c b)) '(b c b)]))

     (test-suite "fib"
     (test-equal-if-defined
      fib
      [(fib 0) 0]
      [(fib 1) 1]
      [(fib 7) 13]
      [(fib 18) 2584]))

     (test-suite "binary->natural"
     (test-equal-if-defined
      binary->natural
      [(binary->natural '(0)) 0]
      [(binary->natural '(0 0 1)) 4]
      [(binary->natural '(0 0 1 1)) 12]
      [(binary->natural '(1 1 1 1)) 15]
      [(binary->natural '(1 0 1 0 1)) 21]
      [(binary->natural '(1 1 1 1 1 1 1 1 1 1 1 1 1)) 8191]))

   (test-suite "minus"
   (test-equal-if-defined
    minus
    [(minus 5 3) 2]
    [(minus 100 50) 50]))

   (test-suite "div"
   (test-equal-if-defined
    div
    [(div 25 5) 5]
    [(div 36 6) 6]))

   (test-suite "set-difference"
   (test-equal-if-defined
    set-difference
    [(set-difference '(1 2 3 4 5) '(2 4 6 8))
     '(1 3 5)]))


   (test-suite "powerset"   
     (test-equal-if-defined powerset
       [(letrec
          ((<-set
            (lambda (s1 s2)
              (cond
               ((null? s1) #f)
               ((null? s2))
               ((< (car s1) (car s2)) #f)
               ((< (car s2) (car s1)))
               (else (<-set (cdr s1) (cdr s2)))))))
          (sort (map (lambda (s) (sort s >)) (powerset '())) <-set))
        '(())]
       [(letrec
          ((<-set
            (lambda (s1 s2)
              (cond
               ((null? s1) #f)
               ((null? s2))
               ((< (car s1) (car s2)) #f)
               ((< (car s2) (car s1)))
               (else (<-set (cdr s1) (cdr s2)))))))
          (sort (map (lambda (s) (sort s >)) (powerset '(2 0 1))) <-set))
        '((2 1 0) (2 1) (2 0) (2) (1 0) (1) (0) ())]
       [(letrec
          ((<-set
            (lambda (s1 s2)
              (cond
               ((null? s1) #f)
               ((null? s2))
               ((< (car s1) (car s2)) #f)
               ((< (car s2) (car s1)))
               (else (<-set (cdr s1) (cdr s2)))))))
          (sort (map (lambda (s) (sort s >)) (powerset '(1 3 4 5))) <-set))
        '((5 4 3 1)
          (5 4 3)
          (5 4 1)
          (5 4)
          (5 3 1)
          (5 3)
          (5 1)
          (5)
          (4 3 1)
          (4 3)
          (4 1)
          (4)
          (3 1)
          (3)
          (1)
          ())]))

   
   (test-suite "cartesian-product"   
     (test-equal-if-defined cartesian-product
       [(letrec
          ((>=-tuple
	    (lambda (t1 t2)
	      (cond
	       ((null? t1))
	       ((> (car t1) (car t2)))
	       ((> (car t2) (car t1)) #f)
	       (else (>=-tuple (cdr t1) (cdr t2)))))))
          (sort (map (lambda (s) (sort s >)) (cartesian-product '((7 6 5) (3 2)))) >=-tuple))
        '((7 3) (7 2) (6 3) (6 2) (5 3) (5 2))]))   

